# OSI 7계층

![img](https://velog.velcdn.com/images%2Fdyllis%2Fpost%2F7a6679e2-26e0-4d3e-b792-c866b9012226%2F%EB%8B%A4%EC%9A%B4%EB%A1%9C%EB%93%9C.png)

Open Systems Interconnection model. **네트워크 통신이 일어나는 과정을 7단계로 나눈 것을 OSI 7계층이라고 한다.**

데이터를 보낼 때에는 상위 계층(7계층) &rarr; 하위 계층(1계층) 순으로 데이터가 전달되고, 데이터를 받을 때에는 반대로 하위 계층(1계층) &rarr; 상위 계층(7계층) 순으로 데이터를 전달받게 된다. 전자를 캡슐화, 후자를 역캡슐화라고 한다. 일종의 마트료시카처럼 캡슐화는 작은 인형을 큰 인형 안에 계속 넣는 거, 역캡슐화는 반대로 큰 인형을 하나씩 열어서 꺼내는 거라고 생각하면 된다.

 

## 7개나?

계층을 나눈 이유는 이렇게 과정을 단계별로 파악했을 때 장점이 많기 때문이다. 한 눈에 이해하기도 쉽고, 어디서 이상이 생겼는지도 빠르게 체크할 수 있기 때문에 **고치기가 쉽다**.

각 계층은 하위 계층을 사용하고, 현 계층의 기능을 포함해서 상위 계층에 제공한다. 즉 최상위 계층만 보면 그 아래 계층들을 모두 볼 수 있다는 뜻.



## 간단한 7형제 소개

### 1 물리계층
말 그대로 하드웨어 전송 기술로 이루어져 있다. 0과 1의 비트의 기계적인 신호를 물리적인 장치로 쏘고 받는 계층이다. 그냥 신호만 주고 받기 때문에 데이터의 종류나 오류 제어에 관여하지 않는다.

전송 단위: bit
프로토콜: RS-232C 등
장비: 허브, 통신 케이블, 리피터 등



### 2 데이터 링크 계층

오류 제어를 하는 곳이 여기다. 두 개의 개방 시스템들 간의 효율적이고 신뢰성 있는 정보 전송을 위해 오류의 검출과 회복을 담당한다. 또한 송수신 사이의 속도 차이를 해결하기 위한 흐름 제어 기능도 여기서 처리하고, 프레임의 시작과 끝을 구분하기 위한 프레임 동기화 기능도 한다.

전송 단위: Frame
프로토콜: 이더넷, MAC, PPP 등
장비: 스위치, 브릿지 등



### 3 네트워크 계층

우리에게 친숙한 IP주소를 제공하는 계층이 여기다. 대표적으로 노드들을 거칠 때마다 라우팅해주는(경로를 찾아주는) 역할이다. 2 데이터 링크 계층이 노드와 노드 사이를 담당한다면 여기는 시작점부터 목적지까지 전체적으로 전달되도록 하는 역할을 담당한다.
다양한 길이의 데이터를 네트워크들을 통해 전달하고, 그 과정에서 각 계층이 요구하는 서비스 품질을 제공하기 위한 기능적, 절차적 수단을 제공한다.

전송단위 : 패킷(Packet)
프로토콜 : IP, ICMP 등
장비 : 라우터, L3 스위치



### 4 전송 계층

통신을 활성화하기 위한 계층. 포트를 열어서(주소를 설정해서) 응용 프로그램들이 전송을 할 수 있게 만든다. 데이터가 왔다면 패킷의 전송이 유효한지 체크하고 전송에 실패한 패킷을 다시 보내는 등의 신뢰성 있는 통신을 보장해서 데이터들을 통합한 다음 5계층으로 전달한다.

전송단위 : 세그먼트(Segment)
프로토콜 : TCP, UDP 등
장비 : 게이트웨이, L4 스위치



### 5 세션 계층

여기서부터 데이터를 만들어내는 계층들이다. 양 끝단의 응용 프로세스가 통신을 관리하는 방법을 제공한다. 통신 연결이 손실되면 연결 복구 시도를 하고, 연결 시도 중 장시간 연결이 되지 않으면 프로토콜의 연결을 닫고 다시 연결을 시도한다. 

프로토콜 : NetBIOS, SSH, TLS



### 6 표현 계층

7 응용 계층과 5 세션 계층 사이에 왔다갔다 하는 데이터들을 보내기 전에 각 계층의 통신에 적당한 형태로 변환하는 역할을 한다(코드 간 번역). 코드 변환, 구문 검색, 데이터 압축 및 암호화 등의 기능이 있다.

프로토콜 : JPG, MPEG, SMB, AFP



### 7 응용 계층

응용 프로세스와 직접 관계해서 일반적인 응용 서비스를 수행하는 계층이다. 최종 사용자에게 가장 가까운, 정말 우리가 사용하는 사용자 인터페이스를 제공하는 프로그램들을 일컫는다. 

프로토콜 : DNS, FTP, HTTP



## 2계층, 데이터 링크

1계층인 물리 계층에서는 허브를 통해 무지성으로 데이터를 보낸다. 내가 같은 네트워크 상의 저 컴퓨터를 콕 집어서 데이터를 보내고 싶어도 허브에 연결되어있는 모든 컴퓨터에게 아무런 검증 없이 보내진다. 이러한 방식을 더 다듬기 위해 2계층, 데이터 링크 계층이 존재한다.



### 프로토콜: 이더넷

이더넷Ethernet은 랜Local Area Network에서 적용되는 프로토콜이다. 



#### MAC 주소

이더넷은 MAC(Media Access Control) 주소라는 것을 정의한다. 랜 카드가 제조될 때 붙여지기 때문에 물리 주소라고도 불리며, 모든 랜카드의 MAC 주소는 다르다. 겹칠 수가 없다. 일종의 주민등록번호인 셈이다.

MAC 주소는 48bit의 16진수 숫자로 이루어져있다. 앞의 24bit는 랜카드 제조사 번호, 뒤의 24bit는 해당 랜카드 제조사가 랜카드에 할당한 고유 번호다.



#### Frame

네트워크 케이블을 통해 전송되는 단위를 우리는 프레임이라 부른다. 프레임은 이더넷 헤더, 전송하고자 하는 데이터, 그리고 FCS로 구성되어 있다.
데이터를 7 &rarr; 1로 전송하면서 캡슐화 할 때마다 각 계층에서 인식할 수 있는 헤더를 붙이게 된다. 1계층이 가장 헤더가 많은 셈인데, 2계층에서는 이더넷 헤더와 트레일러(FCS)가 붙는다.

##### 이더넷 헤더

이더넷 헤더는 목적지 MAC 주소 6byte, 출발지 MAC 주소 6byte, 유형(프로토콜) 2byte로 이루어져 있다. 목적지가 적혀있으니 이상한 곳으로 간다 해도 랜카드들이 자기 주민번호가 아니면 정보를 파기해서 보안 이슈도 어느 정도 해결하게 하는 헤더다.

##### FCS

트레일러라고도 부르는데, 데이터 전송 중 오류가 발생하는지 확인하는 용도다.



### 스위치

2계층에서 데이터들은 위의 프로토콜로 움직이게 되는데, 그 장비가 바로 스위치이다. 



#### 허브가 어때서?

* 반이중 통신: 데이터의 송수신을 번갈아가면서 함
* 전이중 통신: 데이터의 송수신을 동시에 함

허브는 **반이중 통신**을 사용한다. 1차선 도로라고 생각하면 된다.
그런데 만약 서로 다른 컴퓨터가 동시에 데이터를 전송하려고 하면? 1차선에 차량 두 대가 동시에 끼어든다면? 충돌이 일어날 수 있다. 그래서 어느 한 쪽이 케이블에 빈 자리가 날 때까지(데이터가 전송될 때까지) 기다려야 할 것이다. 이러한 방식을 CSMA/CD라고 한다.

하지만? 스위치는 **전이중 통신**을 사용한다. 송신과 수신에 쓰이는 선이 나뉘어져있기 때문이다. 그러므로 CSMA/CD 매커니즘이 필요없어진다. (실제로 현재 CSMA/CD는 거의 쓰이지 않는다.)



허브는 가지지 못 한 스위치의 특징으로는 'MAC 주소 테이블'이 존재한다는 점이다. 스위치의 포트 번호와 그 포트에 연결되어 있는 컴퓨터의 각 MAC 주소가 등록되어 있는 데이터베이스다. 



#### 어떻게 동작하나요?

1. 새로 산 스위치에 컴퓨터들을 연결했다. 우리는 이제 컴퓨터 A에서 컴퓨터 D로 데이터를 전송하려고 한다. 그때 데이터는 스위치를 거치게 되는데, 이때 새 MAC 주소 테이블에 A의 MAC 주소가 찍힐 것이다.
2. 컴퓨터 D를 찾으려고 하니 새 스위치라서 MAC 주소 테이블에 D의 주소가 없다. 이럴 때 스위치가 하는 것이 바로 **플러딩Flooding**이다. 출발지를 제외한 모든 컴퓨터에 데이터를 전송해본다. 그러면 목적지 MAC 주소와 다른 컴퓨터들은 데이터를 파기할 것이고, 컴퓨터 D가 데이터를 가져가면서 D의 주소가 이거구나 , 하고 MAC 주소 테이블에 이제 D의 MAC 주소가 찍힌다.
3. 이제 우리의 스위치는 A와 D의 주소를 안다. 다음에 A에서 D로 보낼 때에는 데이터를 필터링하여 D에게만 데이터를 전송할 것이다. 이게 데이터 막 뿌리는 허브와의 차이점이다.



### ARP(Address Resolution Protocol)

위에서부터 내려오는 데이터는 3계층에서 IP주소는 알아도 2계층에 왔을 때 MAC 주소를 모른다. 그래서 나오는 게 ARP라고 할 수 있다.

ARP는 목적지 컴퓨터의 IP 주소(논리적 주소)를 활용해 MAC 주소(물리적 주소)를 찾기 위한 프로토콜이다. 목적지의 MAC 주소를 모른다면 이를 알아내기 위해 IP주소를 브로드캐스팅(해당 네트워크 상의 모든 컴퓨터에 요청하는 것) 하는데, 이를 ARP 요청이라고 한다. 그 IP 주소에 해당하는 컴퓨터가 ARP 응답을 주면, 이를 통해 알아내는 것이다.



## 3계층, 네트워크

2계층 데이터 링크 계층에서는 같은 네트워크를 쓰는 컴퓨터들끼리 데이터를 주고받을 수 있다. 그리고 다른 네트워크의 컴퓨터들끼리 데이터를 주고받을 수 있게 하는 게 바로 3계층, 네트워크 계층의 역할이다.
2계층에서 스위치라는 장비를 사용해 상대방의 MAC 주소로 보냈다면, 3계층에서는 라우터router라는 장비를 사용해 상대방의 IP 주소로 보낸다. 또한 어떤 경로로 보낼지 정하는데, 그걸 라우팅routing이라고 한다.



### 프로토콜: IP(Internet Protocol)

#### IP주소

ISP(인터넷 서비스 제공자)에게서 받는다. 쉽게 말해 인터넷 사용하려고 신청한 통신사를 의미한다. 

MAC과는 다르게 32bit 10진수로 표시되는데, 요즘은 IP가 부족한 상황이라 ISP에서 주는 IP주소만 라우터에 할당하고, LAN에 속하는 호스트들은 사설 IP주소를 받거나 라우터의 DHCP 기능을 사용해 주소를 자동으로 할당하게 된다. 참고로 사설 주소는 중복될 수 있다.
(멋진 비유를 찾았는데, 사설 주소는 101동 101호처럼 흔하게 중복될 수 있지만, 공인 주소가 시그니엘 서울, 한남더힐 같은 고유한 주소라서 구분이 가능해진다.)

IP 버전에는 IPv4, IPv6의 두 가지가 있다. 전자는 32bit로, 후자는 128bit로 구성되어 있다. IP가 부족해져서 만들어진 게 IPv6이다. IPv4가 약 43억 개라면, IPv6은 340간(...만억조경해자양구'간' 순이다) 개라고 한다.



#### 패킷

네트워크 계층에서는 캡슐화 할 때 IP 헤더를 붙인다. IP 헤더 + 데이터 순으로 붙인 걸 우리는 IP 패킷이라고 하고, 이게 하나의 전송 단위가 된다.(2계층에서 프레임과 같은 위치다.)

IP헤더는 꽤 다양한 걸 담고 있다. 버전, 헤더 길이, 서비스 유형, 전체 패킷 길이, ID, flags, fragment offset, TTL, 프로토콜, 헤더체크섬, 출발지 IP, 목적지 IP ...의 순서로 헤더가 구성된다.



### IP의 구조

IP 주소는 네트워크 ID와 호스트 ID로 구성되어 있다. 전자는 자신이 속한 네트워크를 나타내고, 후자는 해당 네트워크 내에서 어떤 컴퓨터인지를 나타낸다. 말하자면 이 네트워크의 이 컴퓨터, 라고 적힌 주소인 셈이다.

근데 전체 주소에서 이 네트워크 ID와 호스트 ID의 길이를 조정할 수 있다. 네트워크 ID를 크게 쓸 수도, 호스트 ID를 크게 쓸 수도 있다. 이렇게 ID 크기를 나누는 것을 '클래스 개념으로 나눈다'고 표현한다.

![img](https://t1.daumcdn.net/cfile/tistory/1264F6474E47513F25)

| 클래스  | 내용                                                |
| ------- | --------------------------------------------------- |
| A class | 대규모 네트워크                                     |
| B class | 중간 규모 네트워크                                  |
| C class | 소규모 네트워크                                     |
| D class | 멀티캐스트 주소(일반 사용자는 사용하지 못 함)       |
| E class | 연구 및 특수용도 주소(일반 사용자는 사용하지 못 함) |

8bit의 네 칸으로 나뉘는데, 보통 8bit 하나를 하나의 옥텟이라고 부른다. 

A 클래스는 호스트ID가 많은 만큼 배정해야 할 호스트가 많다. 1옥텟의 범위는 1~127, 2~4옥텟의 범위는 0~255이다.

B 클래스는 앞의 2옥텟이 네트워크 ID고, 1 옥텟의 범위는 128~191이다. 

C 클래스의 1 옥텟 범위는 192~233이다. C로 내려올수록 최대 호스트 수가 줄어든다.

#### 네트워크 주소와 브로드캐스트 주소

* 네트워크 주소
  : 호스트 ID가 10진수로 모두 0인 주소. 네트워크를 대표하는 IP 주소
* 브로드캐스트 주소
  : 호스트 ID가 10진수로 모두 255인 주소. 해당 네트워크에 있는 모든 컴퓨터에게 데이터를 전송할 때 사용되는 IP 주소



#### 서브넷

A 클래스의 최대 호스트 수는 약 1678만 개다. A 클래스에서 만약 1678만 개의 컴퓨터에게 동시에 브로드캐스트로 패킷을 전송한다고 생각해보자. 한 번에? 벌써 힘들다. 트래픽이 난리날 것이다.

그래서 생긴 개념이 '서브넷'이다. 대규모 네트워크를 작은 네트워크들로 분할하는 것을 서브넷팅이라 하고, 그렇게 분할된 각각의 네트워크를 서브넷이라고 한다. 사이더(CIDR)라고도 불린다.

서브넷을 사용하게 된다면 기존의 네트워크 ID와 호스트 ID로 구성되었던 IP 주소가 네트워크 ID, 서브넷 ID, 호스트 ID 이렇게 세 개로 세분화된다. 서브넷 ID는 호스트 ID의 일부를 사용하게 된다.

그러면 서브넷 ID는 호스트 ID의 어디서부터 시작될까? 이를 나타내는 게 '서브넷 마스크'다. 

* A 클래스 서브넷: 255.0.0.0 (프리픽스 표기: /8)
* B 클래스 서브넷: 255.255.0.0 (프리픽스 표기: /16)
* C 클래스 서브넷: 255.255.255.0 (프리픽스 표기: /24)

만약 A 클래스 네트워크 호스트 ID의 3 자리 bit를 빌려 서브네팅 한다면 /11이 될 것이다.



### 라우터와 라우팅

![image](https://media.vlpt.us/images/april_5/post/bd201dcb-b578-4a47-b2d2-9b39a86678b6/image.png)

3계층이 2계층의 상위개념이듯 라우터와 스위치도 비슷하다. 각 네트워크 내 컴퓨터는 스위치로 연결되고, 그 스위치들이 라우터에 연결되어 네트워크 간 연결이 가능하다.



#### 라우팅

현재 네트워크에서 다른 네트워크로의 최적의 경로를 찾고 데이터를 전송하는 기술을 말한다. 라우팅을 하려면 출발지와 목적지의 네트워크 정보, 목적지로 가는 모든 경로, 최적 경로를 모두 알아야 하고 지속적인 네트워크 상태 확인도 필요하다.



##### 홉 바이 홉

MAC 주소는 '다음' 전송처의 주소다. 여기서 전송처는 경로에서 다음 지점의 라우터를 말한다. 이렇게 다음 라우터로 한 칸 가는 단위를 '홉'이라고 하고, 여러 지점의 라우터(홉)를 거쳐서 데이터를 단계적으로 전송하는 방식을 '홉 바이 홉'이라고 한다.



##### 경로 선택

여러 지점으로의 최적 경로를 저장해두는 곳을 '라우팅 테이블'이라고 한다. 라우팅 테이블 상에서 수신처의 IP 주소와 가장 일치하는(최장 일치) 라우터의 IP 주소를 찾아서 거기로 전송하게 된다.



##### 경로 탐색

그렇다면 라우팅 테이블은 어떻게 그 경로들을 알 수 있을까? 라우팅 테이블을 구성하는 방식은 크게 두 가지로 나뉘어진다.

* 정적 라우팅 Static Routing
  : 관리자가 직접 수동으로 라우터에 필요한 정보들을 입력한다. 네트워크 변화에 자동으로 반응을 못 하므로 관리자가 계속 설정해줘야 하는 번거로움이 있다.
* 동적 라우팅 Dynamic Routing
  : 라우팅 프로토콜을 이용하여 자동으로 정보를 수집한다. 라우터에 연결된 모든 지점으로 데이터를 전송해보고 최적 경로를 찾아내서 테이블을 구성하는 방식이다. (어떤 경로가 최적 경로인지 판단하는 기준을 메트릭metric이라고 한다.) 동적 라우팅은 네트워크 변화에 대해 자동으로 반응한다.
  하지만 동적 라우팅은 모든 지점으로 데이터를 보내보기 때문에 느릴 수도 있고, 결정적으로 모든 라우터가 동일한 정보를 가져야 한다. 이걸 컨버전스라 부른다.



## 예상 질문

* 네트워크, ISP, 라우터 등의 개념과 각 레이어의 간략한 설명
* 허브, 스위치, 라우터의 차이점



## 참조

https://velog.io/@dyllis/OSI-7%EA%B3%84%EC%B8%B5-%EC%A0%95%EB%A6%AC

https://onecoin-life.com/19

https://madplay.github.io/post/network-osi-7-layer

https://velog.io/@jakeseo_me/OSI-7%EA%B3%84%EC%B8%B5-%EC%8B%9C%EB%A6%AC%EC%A6%88-2-%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%A7%81%ED%81%AC-%EA%B3%84%EC%B8%B5

https://losskatsu.github.io/os-kernel/network-basic03/#

https://losskatsu.github.io/os-kernel/network-basic04/#4-%EB%9D%BC%EC%9A%B0%ED%84%B0

https://velog.io/@gringrape200/OSI-3-%EA%B3%84%EC%B8%B5-%EB%9D%BC%EC%9A%B0%ED%8C%85

https://jeonghoon.netlify.app/Network/layer_3_router/
