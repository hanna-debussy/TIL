# 메모리

## Main Memory

메인 메모리란 **CPU가 직접 접근할 수 있는 기억장치**이다. 기억들의 주소를 가진 바이트들의 배열이라 볼 수 있다.

* 프로그램의 프로세스가 실행되려면 프로그램이 복사되어 이 메인 메모리에 전부 올라와야 한다.
* 또한 현재 처리 중인 데이터나 명령만을 일시적으로 저장하는 **휘발성 메모리**이기 때문에 컴퓨터가 꺼진 이후에는 그동안 메인 메모리에 저장되어있던 모든 데이터가 날아간다.
* 보조기억장치보다 접근 속도가 빠르다.



우리가 컴퓨터를 실행하고 프로그램을 돌리기 위해서는 이 메인 메모리에 두 가지가 올라가있어야 한다. 하나는 운영체제, 그리고 하나는 사용자 프로세스이다. 그래서 우리가 컴퓨터를 좀 더 효율적으로 사용하기 위해서는 이 메인 메모리를 '잘' 분할하고 할당해야 한다.



### MMU (Memory Management Unit)

얘가 메모리 관리에서 핵심적인 역할을 담당한다. 



먼저, 프로세스의 주소는 논리적 주소(Logical Address)와 물리적 주소(Physical Address)로 나뉜다.

* 논리적 주소
  : 가상 주소라고도 하는데, CPU가 사용하고 있는 주소로 물리적 주소와는 상관이 없다. 하나의 프로세스가 메모리에 저장되는 논리적인 모습을 가상 메모리에 구현했다고 해서 '가상' 주소로 불린다.
* 물리적 주소
  : 실제 메모리에 로드되어있는 주소를 뜻한다.



그리고 MMU는 이 가상 메모리에서의 **논리적 주소와 실제 메모리에서의 물리적 주소를 변환**해준다. 



#### 가상 주소의 필요성

다양한 사용자들의 컴퓨터 시스템들은 똑같은 물리 주소를 가지는 게 아니다. 이 차이를 고려하려면 컴퓨터마다 매번 주소를 메모리와 매핑시키는 등 해야 할 일이 많아진다. 또한 메모리는 한정적이고 메인 메모리로의 직접 접근은 비효율적이기 때문에, 이를 보완하기 위한 가상 메모리에서 쓰는 게 논리 주소이다. 논리 주소는 물리 주소와 무관하기 때문에 똑같을 필요가 없다. 

이렇게 가상 주소가 필요한데, 가상 주소에서 빠르게 물리 주소로 변환을 해야 실제 데이터를 가져올 수 있기 때문에 이 MMU가 존재하는 것이다.



그래서 MMU의 역할을 정리하자면 다음과 같다.

1. MMU가 없다면, 메인 메모리에 직접 물리 주소로 접근해야 하는데 이는 비효율적이다.
2. 사용자가 주소를 일일이 할당해야 하는 불편을 없애준다.
3. 프로세스의 크게가 실제 메모리 용량을 초과해도 실행될 수 있게 해준다. (= 가상 메모리 사용 가능)
4. 그 외 메모리 보호나 캐시 관리 등 CPU가 메모리에 접근하는 것을 관리해준다.



#### Memory Protection

![Operating Systems: Main Memory](https://www.cs.uic.edu/~jbell/CourseNotes/OperatingSystems/images/Chapter8/8_02_HardwareAddressProtection.jpg)

또한 MMU는 **memory protection** 역할도 한다.

가상 주소는 VPN(Virtual Page Number)와 offset으로 나뉜다. 보통 전체 프로세스를 메인 메모리에 냅다 올리는 게 아니라, page 단위로 쪼갠 코드들을 동적으로 필요할 때마다 올리는데, 그 page들의 번호(index) 역할을 하는 걸 VPN이라고 생각하면 된다. 

그런데 page 번호가 400이고 offset이 700이라고 치자. 그러면 400+700 해서 1100의 번호를 가진 메모리에 접근을 해야 하는데 만약 메모리가 1000짜리라면? 이렇게 잘못된 메모리 주소를 참조하지 않도록 막아주는 게 바로 memory protection이다.

그걸 위해 MMU에는 limit register가 추가된다. 이 레지스터는 프로세스의 사이즈를 저장해서, 이 영역 밖의 접근을 요구하면 그땐 trap을 발생시킨다.

> **memory protection trap(fault)**
>
> 유효하지 않은 메모리 주소를 참조하라는 명령어일 때, CPU가 스스로 interrupt를 걸어서 운영체제에게 이거 해결해줘! 하고 알려주는 것 (그러면 OS가 그 전 처리들 save하고 block하고... 등등의 일을 처리해준다)



### 메모리 과할당(Memory Over Allocating)

과할당이 문제되는 경우는 실행 도중 page fault가 발생했을 때 &rarr; 그 page fault가 발생한 페이지 위치를 디스크에서 찾게 되고 &rarr; 그 문제된 page는 새로운 다른 빈 메모리 프레임에 올려야 하는데, 메모리가 전부 사용 중이라 빈 프레임이 없을 때이다. 

> page fault
> : 프로세스가 필요로 하는 page가 없는 경우

빈 프레임이 없어서 일어난 일이니 과할당을 해결하기 위해서는 빈 프레임을 확보해야 한다. 그러기 위해서 쓰이는 기법이 바로 페이지 교체(Page Replacement) 기법이다. 한 마디로 새로 올릴 페이지와 그로 인해 교체될 희생 프레임을 찾는 거다.



### 페이지 교체

프로세스 하나를 swap out해서 빈 프레임을 확보하는 것을 말한다.

1. page fault가 발생해서 빈 프레임이 필요한데 없을 경우, 희생 프레임을 선정한다
2. 디스크에 그 희생 프레임의 변경 사항을 기록하고 페이지 테이블을 업데이트한다
3. 희생 프레임을 내리고 그 프레임에 page fault가 발생한 페이지를 올린 다음 페이지 테이블을 업데이트 한다



이때 2번과 3번에서 각각 한 번씩 총 두 번의 디스크 접근이 이루어지는데, 이렇게 페이지 교체가 많이 이루어진다면 오버헤드가 커져서 페이지를 슥삭 교체할 때 사용자가 불편함을 느낄 수 있다. 그러므로 여기서 관건은 프로세스를 계속 문제 없이 수행시키기 위한 오버헤드 감소가 되겠다.



#### 오버헤드 감소시키기

##### 실제로 디스크 접근 횟수를 낮추기: 변경 비트 두기

모든 페이지마다 변경 비트(register)를 두어서, 변경된 페이지가 아니라면 딱히 디스크에 기록할 필요 없이 희생 프레임을 내리게 한다. 정확히는

* 해당 비트가 set state라면 그 페이지가 단 한번이라도 수정이 일어나서 디스크 상의 내용과 페이지 내용이 달라졌음을 뜻한다. 그러므로 디스크에 기록해야 한다.
* 해당 비트가 clear state라면 디스크 상의 내용과 메모리 상의 내용이 일치하므로 디스크에 기록할 필요가 없다. 



##### 페이지 교체 알고리즘

새로 올릴 프레임과 희생 프레임을 '잘' 찾아 page fault(page 부재율)를 줄이는 것을 목표로 하는 알고리즘들이다.

* FIFO
  : 가장 먼저 올라온 페이지를 가장 우선적으로 내보낸다.

  > 하지만 페이지 프레임을 더 많이 사용하는데(메모리를 증가시켰는데) 페이지 부재가 더 많이 일어나는 FIFO anomaly가 발생할 수 있다.

* LRU
  : 가장 오랫동안 사용하지 않은 페이지를 우선적으로 내보낸다. 즉, 페이지 교체 시 가장 오래 전에 참조가 이루어진 페이지를 내보낸다. 많은 운영체제가 이 알고리즘을 채택하고 있다.

* NUR
  : LRU와 비슷하게, 최근에 사용하지 않은 페이지를 우선적으로 내보내지만 차이는 '어떻게 그 페이지를 찾는가'이다. LRU의 단점이 가장 오래 전에 참조가 이루어진 페이지를 찾는 데에서 시간 오버헤드가 발생한다는 것이었는데, 이를 보완하기 위해 NUR은 참조 비트와 변형 비트를 사용한다. 

  * 참조 비트: 페이지가 호출되었을 때에는 1, 호출되지 않았다면 0
  * 변형 비트: 페이지 내용이 변경되었다면 1, 변경되지 않았다면 0

* LFU
  : 과거에 참조 '횟수'가 가장 적은 페이지를 우선적으로 내보낸다.

* MFU
  : LFU와 반대로, 참조 횟수가 가장 많은 페이지를 우선적으로 내보낸다.

* OPT
  : optimal, 즉 앞으로 가장 오랫동안 사용하지 않을 페이지를 우선적으로 내보낸다. 대신 프로세스가 앞으로 사용할 페이지를 미리 알아야 하기 때문에 실제로는 구현하기 거의 불가능하고, 보통 연구 목적으로만 사용된다.





## 캐시 메모리

캐시 메모리는 [여기](../Computer_Architecture/0427_캐시메모리.md)에서 자세히 볼 수 있다.



## 면접 예상 문제

* MMU란?
* 메모리 과할당과 그 해결책에 대해 설명하시오.



## 참고

https://m.blog.naver.com/sungeuns/50098147696

https://jhnyang.tistory.com/247

https://ybdeveloper.tistory.com/61

https://jennysgap.tistory.com/entry/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C%EC%9D%98-%EA%B8%B0%EC%B4%88-17-Demand-Paging-1

https://broseob.tistory.com/60

https://liveyourit.tistory.com/235

https://medium.com/pocs/%ED%8E%98%EC%9D%B4%EC%A7%80-%EA%B5%90%EC%B2%B4-page-replacement-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-650d58ae266b